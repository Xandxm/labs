#include <iostream>
#include <cstdlib>

using namespace std;

// Удаление столбцов по массиву индексов
void deleteColumns(int** &M, int &rows, int &cols, int* zeroCols, int zeroCount) {
    if (zeroCount == 0) return;

    // создаём новую матрицу с уменьшенным количеством столбцов
    int newCols = cols - zeroCount;
    int** newM = (int**)malloc(rows * sizeof(int*));
    for (int i = 0; i < rows; i++) {
        newM[i] = (int*)malloc(newCols * sizeof(int));
    }

    // копирование со сдвигом (пропуская запрещённые столбцы)
    int writeCol;
    for (int i = 0; i < rows; i++) {
        writeCol = 0;
        for (int j = 0; j < cols; j++) {
            bool remove = false;
            for (int k = 0; k < zeroCount; k++) {
                if (j == zeroCols[k]) { remove = true; break; }
            }
            if (!remove) {
                newM[i][writeCol] = M[i][j];
                writeCol++;
            }
        }
    }

    // освобождаем старую
    for (int i = 0; i < rows; i++)
        free(M[i]);
    free(M);

    // меняем указатель
    M = newM;
    cols = newCols;
}

int main() {
    int A, B, C, D;

    // Чтение A, B с проверкой
    do {
        cout << "Введите A (>=0): ";
        cin >> A;
        if (A < 0) cout << "Ошибка! A не может быть отрицательным.\n";
    } while (A < 0);

    do {
        cout << "Введите B (>=0): ";
        cin >> B;
        if (B < 0) cout << "Ошибка! B не может быть отрицательным.\n";
    } while (B < 0);

    cout << "Введите C и D: ";
    cin >> C >> D;

    // Исходная матрица 2×2
    cout << "Введите исходные 4 числа (2×2):\n";
    int base[2][2];
    for (int i = 0; i < 2; i++)
        for (int j = 0; j < 2; j++)
            cin >> base[i][j];

    int rows = 2 + A;   // добавленные строки
    int cols = 2 + B;   // добавленные столбцы

    // создаём матрицу через malloc
    int** M = (int**)malloc(rows * sizeof(int*));
    for (int i = 0; i < rows; i++)
        M[i] = (int*)calloc(cols, sizeof(int));

    // вставляем исходную 2×2 в левый верхний угол
    M[0][0] = base[0][0];
    M[0][1] = base[0][1];
    M[1][0] = base[1][0];
    M[1][1] = base[1][1];

    // заполнение по формуле i*C + j*D
    // i = 0..A   (строки)
    // j = 1..B   (столбцы)
    for (int i = 0; i <= A; i++) {
        for (int j = 1; j <= B; j++) {
            M[i][j + 1] = i * C + j * D;   // j+1 потому что первые 2 столбца заняты исходными
        }
    }

    // поиск нулей
    int* zeroCols = (int*)malloc(cols * sizeof(int));
    int zeroCount = 0;

    for (int j = 0; j < cols; j++) {
        for (int i = 0; i < rows; i++) {
            if (M[i][j] == 0) {
                zeroCols[zeroCount++] = j;
                break;
            }
        }
    }

    // удаление столбцов по найденным индексам
    deleteColumns(M, rows, cols, zeroCols, zeroCount);
    free(zeroCols);

    // вывод итоговой матрицы
    cout << "\nИтоговая матрица:\n";
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++)
            cout << M[i][j] << " ";
        cout << "\n";
    }

    // освобождение памяти
    for (int i = 0; i < rows; i++)
        free(M[i]);
    free(M);

    return 0;
}